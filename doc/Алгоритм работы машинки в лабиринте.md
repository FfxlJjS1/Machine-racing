# Содержание

[Home](Home.md)

# Обзор
Данная заметка описывает принцип работы алгоритма прохождения конкретного лабиринта на 2024 год.

## Начальное описание алгоритма
Из-за условия лабиринта получается, что есть всегда только единственный верный путь, который ведет к финишу, а остальные к тупику.

**Поэтому основная задача:** определить в какой последовательности двигаться в определенных позициях (поворотах или тупиках).

Из-за этого нам не нужно хранить весь лабиринт в памяти машинки, а только путь.

Наиболее подходящая структура данных для хранения пути либо односвязный стек, либо двусвязный список.

Временно будет использован односвязный список с его разворотом при прохождении при известном пути.

**Фундаментальные функции машинки:**
- `Определить цвет квадрата`, чтобы определить, дошли ли мы до финиша, или необходимо продолжать искать.
- `Определить тип развилки или тупика`
- `Повернуться на месте на определенный градус`
- `Движение вперед до первой развилки или тупика`, где он остановиться в квадрате с развилками, а не в квадрате до или после развилки.
- `Каллибровка позиции в квадрате`, чтобы машинка сама встала в подходящую позицию в лабиринте для дальнейшего движения.

**Особенности фундаментальных функций машинки:**
- `Определить цвет квадрата` необходимо выполнять только в `Движение вперед до первой развилки или тупика`, при условии, что это первое прохождение, при повторных прохождениях машинка сама остановиться в финишном квадрате

**Есть две главные функции машинки, которые являются входными:**
- `setup` - метод, в котором устанавливаются порты для чтения-записи.
- `loop` - метод, который зациклено работает, при запуске машинки.

Исходя из того, что `loop` зациклен, необходимо определить, когда машинка находиться на паузе, а когда она должна двигаться к финишу.

Из-за того, что алгоритм движения к финишу при первой попытке и остальных отличается, необходимо определить, что это первая попытка или нет.

Также существует особенность того, что движение идет от тупика назад до последней развилки, где остались пути, в которые мы не ходили.

Для того, чтобы убирать из односвязного стека пути, которые ведут к тупику необходимо возврат к последней развилке с путями, где машинка не была, необходимо знать, что мы движемся до подобной развилки.

Также для того, чтобы оптимизировать движение из тупика в другую доступную развилку, было решено на последней развилке с путями, где машинка не была, необходимо сразу поворачивать в эти пути не приходя в состояние, в котором машинка первый раз встретила эту развилку.

## Описание реализации алгоритма
**Реализация состоит из следующих частей:**
1. переменные, константы - область, в которой прописаны коды и константы для работы программы.
2. `setup` функция, в котором определяются пины для работы
3. `loop` функция, в которой происходит движение.

### Переменные и константы
**Переменные:**
1. `steps` - односвязный стек, реализованный через библиотеку Stack.h в Arduino IDE.
2. `is_forward` - булево значение, определяющее, что тупик на этом пути встречен не был, если значение истинно, и машинка должна двигаться до последней развилки, где остались неразведанные пути, если значение ложно.
3. `is_first_start` - булево значение, определяющее, что это первая попытка для машинки и путь еще не известен, если значение истинно, и путь уже известен и надо двигаться по пути из `steps`, если значение ложно.
4. `is_paused` - булево значение, определяющее, что машинка должна ждать, если значение истинно, и должна искать, если значение ложно.

**Один элемент `steps` содержит два значение:**
- `шаг`, который должен быть сделан при при движении вперед, и шаг, который был сделан при движении назад.
- `тип развилки`.

**Для оптимизации хранения данных элемент steps храниться как 8 битов данных, где:**
- `4 старших бита` - код, описывающий куда должна поехать машинка или куда поехала, если движется назад до последней развилки.
	- `0000` - стоп
	- `0001` - прямо
	- `0010` - поворот вправо
	- `0100` - поворот влево
	- `1000` - разворот на месте
- `4 младших бита` - код, описывающий тип развилки.
	- `0100` - прямая развилка, используется для стартовой точки, если она такая
	- `0001` - развилка только вправо
	- `0010` - развилка только влево
	- `0011` - развилка и вправо и влево
	- `0100` - движение вперед
	- `0101` - развилка вправо и прямо
	- `0110` - развилка влево и прямо
	- `0111` - развилка вправо, прямо и влево
	- `0000` - движение только назад, до предыдущей развилки, где возможно другое движение

Для получения старших и младших битов элемента `steps` отдельно были созданы функции:
- `get_path_type` - функция, возвращает 4 старших бита. Они возвращают их как число, в котором код занимает 4 младших бита.
- `get_step_path` - функция, возвращает 4 младших бита. Они возвращают их как число, в котором код занимает 4 младших бита.

**Также была создана функция для комбинирования кода типа развилки и пути движения:**
- `combine__path_type__with__step_path`

### setup функция
Происходит объявление портов на отправку сигналов для моторчиков машинки с последующим вызовом остановки машинки, на всякий случай.

Происходит объявление  портов на отправку для отключения каждого лазерного дальномера.

Происходит объявление порта на отправку и порта на получение сигналов для ульразвукового дальномера.

Происходит инициализация APDS-9960 датчика цвета с выводом результата в Serial.
В последующем происходит включение светового сенсора без interrupts.

В конце происходит определение переменной lox для прослушки активного лазерного дальномера.

Потом происходит ожидание 500 млс для инициализации и калибровка.

### loop функция
**Сама `loop` функция будет состоять из двух частей:**
- область ожидания-запуска машинки - алгоритм, который ожидает запуска программы по поиску иди движению к финишу.
- область алгоритма поиска или движения к финишу

#### Область ожидания-запуска машинки
Так как эта функция повторно запускается, пока машинка работает, было решено добавить алгоритм ожидания запуска программы, работающая с переменной `is_paused`.

Чтобы машинка дождалась нашего отжатия кнопки запуска, а не сразу поехала, сцепившись с пальцем, и не туда уехала, была реализована фаза ожидания состояния 'не нажат' для кнопки

#### Область алгоритма поиска или движения к финишу
Первоначально будет произведена калибровка положения машинки относительно стенок.

В случае если это запуск с поиском пути или с движением к финишу, а не до последней развилки, то необходимо определить тип развилки на позиции машинки в данный момент и тип движения, который необходимо выполнить. Сформированный шаг добавляется в `steps`.

После идеи получение последнего шага из `steps`, т.к. шаг для возврата и движения к финишу по неизвестному или известному пути через `act_to_go`.

`act_to_go` - это метод для выполнения движения согласно шагу.
Сначала там определяется тип шага и тип развилки из шага.
Потом идут следующие возможные сценарии:
- Если тип шага является остановкой, то устанавливается пауза и дополнительно:
	- Если это было первое прохождение, то переворачивается получившийся путь от начала к финишу и сохраняется в `steps_for_save`, если попыток будет больше 2 (1 на исследование, 1 на скорость).
	- Если попытка является повторной, то в `steps` копируется запасной стек `steps_for_save`, т.к. из-за особенностей работы стека из `steps` все шаги были удалены, и, если будет больше повторных прохождениях на скорость, то можно было попробовать быстрее его достичь.
- Если это является первой попыткой (с неизведанным путем к финишу), то:
	- Если движение вперед, то сохраняется в стек движение, которое будет выполнено, и после этого данное движение выполняется.
	- Если движение производится к последней развилке, где остались неизведанные пути, то берется значение движения из `determine_path_to_prev_path`, которое вычисляет как надо повернуть на путях обратно к развилке и на развилке в неизведанный путь против часовой стрелки относительно позиции в которой эта развилка была встречена.
- Если это является повторной попыткой, то выполняется последняя операция перевернутого стека движения от старта до финиша.

### Элементарные функции
#### read_apds_color
Прочитать цвет с датчика цвета APDS-9960 и вернуть структуру apds_color

#### read_distance_from_enable_laser_distancefinder
Прочитать дистанцию с включенного лазера

#### read_distance_from_ultrasonic_distancefinder
Прочитать расстояние с ультразвукового датчика расстояния


#### read_distance_from_left_laser_distancefinder
Включить левый лазер, отключить правый лазер и прочитать дистанцию с включенного лазера

#### read_distance_from_right_laser_distancefinder
Включить правый лазер, отключить левый лазер и прочитать дистанцию с включенного лазера

#### act_to_rotate_to_value
Повернуться по часовой или против часовой относительно вида сверху на месте на определенный коэффициент.

Так как точно задать это невозможно, то используется каллибровка для более точного поворота при поворотах на прямые углы.


#### act_to_go_for_coefficient
Двигаться вперед или назад на определенный коэффициент с последующей остановкой.


#### callibrate_machine_position


#### act_to_go_forward
Двигаться вперед на коэффициент 400 с каллибровкой позиции в конце и определением пути дальнейшего движения до тех пор, пока движение есть только вперед.

#### detect_is_finish
Получает структуру цвета через APDS-9960 и если яркость, синий, красный, зеленый цвет вместе меньше или равны 1.

#### act_to_stop_follow
Остановка машинки


#### determine_path_type
...


#### 