# Содержание

[Home](Home.md)

# Обзор
Данная заметка описывает принцип работы алгоритма прохождения конкретного лабиринта на 2024 год.

## Начальное описание мероприятия
**Условия лабиринта:**
- Лабиринт не имеет зацикленных путей.
- Попыток не менее двух на одной и той же карте с той же позиции.
- Старт происходит с позиции, где есть только один путь и три стены в квадрате, где машинка повернута к доступному пути движения.
- Финишем считается черный квадрат на полу квадрата.
- Размер квадрата лабиринта 30x30.
- Размер машинки 24x24.
- Код машинки не меняется с начала мероприятия.

## Начальное описание алгоритма
Из-за условия лабиринта получается, что есть всегда только единственный верный путь, который ведет к финишу, а остальные к тупику.

**Поэтому основная задача:** определить в какой последовательности двигаться в определенных позициях (поворотах или тупиках).

Из-за этого нам не нужно хранить весь лабиринт в памяти машинки, а только путь.

Наиболее подходящая структура данных для хранения пути либо односвязный стек, либо двусвязный список.

Временно будет использован односвязный список с его разворотом при прохождении при известном пути.

**Фундаментальные функции машинки:**
- `Определить цвет квадрата`, чтобы определить, дошли ли мы до финиша, или необходимо продолжать искать.
- `Определить тип развилки или тупика`
- `Повернуться на месте на определенный градус`
- `Движение вперед до первой развилки или тупика`, где он остановиться в квадрате с развилками, а не в квадрате до или после развилки.
- `Каллибровка позиции в квадрате`, чтобы машинка сама встала в подходящую позицию в лабиринте для дальнейшего движения.

**Особенности фундаментальных функций машинки:**
- `Определить цвет квадрата` необходимо выполнять только в `Движение вперед до первой развилки или тупика`, при условии, что это первое прохождение, при повторных прохождениях машинка сама остановиться в финишном квадрате

**Есть две главные функции машинки, которые являются входными:**
- `setup` - метод, в котором устанавливаются порты для чтения-записи.
- `loop` - метод, который зациклено работает, при запуске машинки.

Исходя из того, что `loop` зациклен, необходимо определить, когда машинка находиться на паузе, а когда она должна двигаться к финишу.

Из-за того, что алгоритм движения к финишу при первой попытке и остальных отличается, необходимо определить, что это первая попытка или нет.

Также существует особенность того, что движение идет от тупика назад до последней развилки, где остались пути, в которые мы не ходили.

Для того, чтобы убирать из односвязного стека пути, которые ведут к тупику необходимо возврат к последней развилке с путями, где машинка не была, необходимо знать, что мы движемся до подобной развилки.

Также для того, чтобы оптимизировать движение из тупика в другую доступную развилку, было решено на последней развилке с путями, где машинка не была, необходимо сразу поворачивать в эти пути не приходя в состояние, в котором машинка первый раз встретила эту развилку.

## Описание реализации алгоритма
**Реализация состоит из следующих частей:**
1. переменные, константы - область, в которой прописаны коды и константы для работы программы.
2. `setup` функция, в котором определяются пины для работы
3. `loop` функция, в которой происходит движение.

### Переменные и константы
**Переменные:**
1. `steps` - односвязный стек, реализованный через библиотеку Stack.h в Arduino IDE.
2. `is_forward` - булево значение, определяющее, что тупик на этом пути встречен не был, если значение истинно, и машинка должна двигаться до последней развилки, где остались неразведанные пути, если значение ложно.
3. `is_first_start` - булево значение, определяющее, что это первая попытка для машинки и путь еще не известен, если значение истинно, и путь уже известен и надо двигаться по пути из `steps`, если значение ложно.
4. `is_paused` - булево значение, определяющее, что машинка должна ждать, если значение истинно, и должна искать, если значение ложно.

**Один элемент `steps` содержит два значение:**
- `шаг`, который должен быть сделан при при движении вперед, и шаг, который был сделан при движении назад.
- `тип развилки`.

**Для оптимизации хранения данных элемент steps храниться как 8 битов данных, где:**
- `4 старших бита` - код, описывающий куда должна поехать машинка или куда поехала, если движется назад до последней развилки.
	- `0000` - стоп
	- `0001` - прямо
	- `0010` - поворот вправо
	- `0100` - поворот влево
	- `1000` - разворот на месте
- `4 младших бита` - код, описывающий тип развилки.
	- `0100` - прямая развилка, используется для стартовой точки, если она такая
	- `0001` - развилка только вправо
	- `0010` - развилка только влево
	- `0011` - развилка и вправо и влево
	- `0100` - движение вперед
	- `0101` - развилка вправо и прямо
	- `0110` - развилка влево и прямо
	- `0111` - развилка вправо, прямо и влево
	- `0000` - движение только назад, до предыдущей развилки, где возможно другое движение

Для получения старших и младших битов элемента `steps` отдельно были созданы функции:
- `get_path_type` - функция, возвращает 4 старших бита. Они возвращают их как число, в котором код занимает 4 младших бита.
- `get_step_path` - функция, возвращает 4 младших бита. Они возвращают их как число, в котором код занимает 4 младших бита.

**Также была создана функция для комбинирования кода типа развилки и пути движения:**
- `combine__path_type__with__step_path`

### setup функция


### loop функция
**Сама `loop` функция будет состоять из двух частей:**
- область ожидания-запуска машинки - алгоритм, который ожидает запуска программы по поиску иди движению к финишу.
- область алгоритма поиска или движения к финишу

#### Область ожидания-запуска машинки
Так как эта функция повторно запускается, пока машинка работает, было решено добавить алгоритм ожидания запуска программы, работающая с переменной `is_paused`.

Чтобы машинка дождалась нашего отжатия кнопки запуска, а не сразу поехала, сцепившись с пальцем, и не туда уехала, была реализована фаза ожидания состояния 'не нажат' для кнопки

#### Область алгоритма поиска или движения к финишу
Первоначально будет произведена калибровка положения машинки относительно стенок.

> В самом первом запуске, после включения машинки, будет выполнен шаг вперед до стенки или развилки.



Сначала будет проверено, какой это тип прохождения: первый или повторный.
Если первый, то 
Если повторный, то берется шаг из `steps` и выполняется через `act_to_go`.


